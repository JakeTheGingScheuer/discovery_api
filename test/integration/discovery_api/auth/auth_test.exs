defmodule DiscoveryApi.Auth.AuthTest do
  use ExUnit.Case
  use Divo, services: [:ldap, :redis]
  alias DiscoveryApi.Data.Model
  alias DiscoveryApi.Test.Helper

  alias SmartCity.TestDataGenerator, as: TDG

  @inactive_token "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJkaXNjb3ZlcnlfYXBpIiwiZXhwIjoxNTU3NzczNTMzLCJpYXQiOjE1NTUzNTQzMzMsImlzcyI6ImRpc2NvdmVyeV9hcGkiLCJqdGkiOiIxYmJkMmUzMy01ZDc1LTRjNTYtYjQ4OS1mOGMxNzViZDg1NDEiLCJuYmYiOjE1NTUzNTQzMzIsInN1YiI6IkJhZFVzZXIiLCJ0eXAiOiJhY2Nlc3MifQ.TzTIVFiSJaPOioTiFYgvfg15BPzFCHx6qj1W1_vQeKPvo_Q4xuY_uA3-h1nobKq35fYu73TQdp_DYwwPQC5PDQ"
  @organization_1_user "FirstUser"
  @organization_2_user "SecondUser"

  setup_all do
    Paddle.authenticate([cn: "admin"], "admin")
    Paddle.add([ou: "People"], objectClass: ["top", "organizationalunit"], ou: "People")
    Enum.each([@organization_1_user, @organization_2_user], fn user -> make_ldap_user(user) end)

    Paddle.add([ou: "Group"], objectClass: ["top", "organizationalunit"], ou: "Group")

    organization_1_cn = "this_is_a_group"
    organization_2_cn = "this_is_a_second_group"

    organization_1 = TDG.create_organization(%{dn: "cn=#{organization_1_cn},ou=Group"})
    organization_2 = TDG.create_organization(%{dn: "cn=#{organization_2_cn},ou=Group"})

    add_ldap_user_to_organization(@organization_1_user, organization_1_cn)
    add_ldap_user_to_organization(@organization_2_user, organization_2_cn)

    private_model_1 =
      Helper.sample_model(%{
        private: true,
        organization: organization_1_cn,
        organizationDetails: organization_1,
        keywords: ["dataset", "facet1"]
      })

    private_model_2 =
      Helper.sample_model(%{
        private: true,
        organization: organization_2_cn,
        organizationDetails: organization_2,
        keywords: ["dataset", "facet2"]
      })

    public_model =
      Helper.sample_model(%{
        private: false,
        organization: organization_1_cn,
        organizationDetails: organization_1,
        keywords: ["dataset", "public_facet"]
      })

    Model.save(private_model_1)
    Model.save(private_model_2)
    Model.save(public_model)

    %{status_code: 200, body: "#{@organization_1_user} logged in.", headers: headers} =
      "http://localhost:4000/api/v1/login"
      |> HTTPoison.get!([], hackney: [basic_auth: {@organization_1_user, "admin"}])
      |> Map.from_struct()

    {"token", token} = Enum.find(headers, fn {header, _value} -> header == "token" end)

    {:ok,
     %{
       authenticated_token_for_org_1: token,
       private_model_1: private_model_1,
       private_model_2: private_model_2,
       public_model: public_model
     }}
  end

  @moduletag capture_log: true
  test "Successfully login via the login url with valid password" do
    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/login"
      |> HTTPoison.get!([], hackney: [basic_auth: {@organization_1_user, "admin"}])
      |> Map.from_struct()

    assert "#{@organization_1_user} logged in." == body
    assert status_code == 200
  end

  @moduletag capture_log: true
  test "Fails attempting to login via the login url with invalid password" do
    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/login"
      |> HTTPoison.get!([], hackney: [basic_auth: {@organization_1_user, "badpassword"}])
      |> Map.from_struct()

    result = Jason.decode!(body, keys: :atoms)
    assert result.message == "Not Authorized"
    assert status_code == 401
  end

  @moduletag capture_log: true
  test "Is able to access a restricted dataset with a cookie generated by login", setup_map do
    %{status_code: 200, body: "FirstUser logged in.", headers: headers} =
      "http://localhost:4000/api/v1/login"
      |> HTTPoison.get!([], hackney: [basic_auth: {"FirstUser", "admin"}])
      |> Map.from_struct()

    {"set-cookie", cookie_string} = Enum.find(headers, fn {header, _value} -> header == "set-cookie" end)
    token = Helper.extract_token(cookie_string)

    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/dataset/#{setup_map[:private_model_1].id}/"
      |> HTTPoison.get!(Cookie: "#{Helper.default_guardian_token_key()}=#{token}")

    result = Jason.decode!(body, keys: :atoms)

    assert setup_map[:private_model_1].id == result.id
    assert status_code == 200
  end

  @moduletag capture_log: true
  test "Is able to access a restricted dataset with a token generated by login", setup_map do
    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/dataset/#{setup_map[:private_model_1].id}/"
      |> HTTPoison.get!(Authorization: "Bearer #{setup_map[:authenticated_token_for_org_1]}")

    result = Jason.decode!(body, keys: :atoms)

    assert result.id == setup_map[:private_model_1].id
    assert 200 == status_code
  end

  @moduletag capture_log: true
  test "Is not able to access a restricted dataset with a bad cookie token", setup_map do
    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/dataset/#{setup_map[:private_model_1].id}/"
      |> HTTPoison.get!(Cookie: "#{Helper.default_guardian_token_key()}=wedidthebadthing")

    result = Jason.decode!(body, keys: :atoms)

    assert result.message == "Not Found"
    assert status_code == 404
  end

  @moduletag capture_log: true
  test "Is not able to access a restricted dataset with a bad token", setup_map do
    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/dataset/#{setup_map[:private_model_1].id}/"
      |> HTTPoison.get!(Authorization: "Bearer sdfsadfasdasdfas")

    result = Jason.decode!(body, keys: :atoms)

    assert result.message == "Not Found"
    assert status_code == 404
  end

  @moduletag capture_log: true
  test "Is not able to access a dataset where group membership does not exist", setup_map do
    %{status_code: status_code, body: body} =
      "http://localhost:4000/api/v1/dataset/#{setup_map[:private_model_2].id}/"
      |> HTTPoison.get!(Authorization: "Bearer #{setup_map[:authenticated_token_for_org_1]}")

    result = Jason.decode!(body, keys: :atoms)

    assert result.message == "Not Found"
    assert status_code == 404
  end

  describe "/api/v1/search" do
    test "filters all private datasets when no auth token provided", setup_map do
      %{status_code: _status_code, body: body} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!()

      %{results: results} = Jason.decode!(body, keys: :atoms)
      result_ids = Enum.map(results, fn result -> result[:id] end)

      assert Enum.member?(result_ids, setup_map[:public_model].id)
      assert 1 == length(results)
    end

    test "only returns facets for authorized datasets", setup_map do
      %{status_code: _status_code, body: body} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(Authorization: "Bearer #{setup_map[:authenticated_token_for_org_1]}")

      %{metadata: %{facets: facets}} = Jason.decode!(body, keys: :atoms)

      assert Enum.find(facets[:keywords], fn facet -> facet[:name] == "facet1" end)[:count] == 1
      assert Enum.find(facets[:keywords], fn facet -> facet[:name] == "public_facet" end)[:count] == 1
      assert Enum.find(facets[:keywords], fn facet -> facet[:name] == "facet2" end) == nil
      assert Enum.find(facets[:keywords], fn facet -> facet[:name] == "dataset" end)[:count] == 2
      assert facets[:organization] == [%{count: 2, name: setup_map.private_model_1.organization}]
    end

    test "when the token is expired the response is a 404" do
      %{status_code: status_code} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(Authorization: "Bearer #{@inactive_token}")

      assert status_code == 404
    end

    test "Allows access to private datasets when auth token provided and is permitted", setup_map do
      %{status_code: _status_code, body: body} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(Authorization: "Bearer #{setup_map[:authenticated_token_for_org_1]}")

      %{results: results} = Jason.decode!(body, keys: :atoms)

      result_ids = Enum.map(results, fn result -> result[:id] end)
      assert Enum.member?(result_ids, setup_map[:private_model_1].id)
      assert Enum.member?(result_ids, setup_map[:public_model].id)
      assert 2 == length(results)
    end
  end

  describe "CookieMonster" do
    test "eats cookies when not from the appropriate origin (ajax)" do
      {:ok, token, _} = DiscoveryApi.Auth.Guardian.encode_and_sign("username", %{}, token_type: "refresh")

      %{status_code: status_code, body: body} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(
          Cookie: "something=true,#{Helper.default_guardian_token_key()}=#{token},somethingelse=false",
          Origin: "jessies.house.example.com"
        )

      response = Jason.decode!(body, keys: :atoms)
      assert response.message == "Not Found"
      assert status_code == 404
    end

    test "eats cookies when from a similar but different origin (ajax)" do
      {:ok, token, _} = DiscoveryApi.Auth.Guardian.encode_and_sign("username", %{}, token_type: "refresh")

      %{status_code: status_code} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(
          Cookie: "something=true,#{Helper.default_guardian_token_key()}=#{token},somethingelse=false",
          Origin: "jessies-integrationtests.example.com"
        )

      assert status_code == 404
    end

    test "does not eat cookies when origin not included (non-ajax or local file)" do
      {:ok, token, _} = DiscoveryApi.Auth.Guardian.encode_and_sign("username", %{}, token_type: "refresh")

      %{status_code: status_code} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(Cookie: "something=true,#{Helper.default_guardian_token_key()}=#{token},somethingelse=false")

      assert status_code == 200
    end

    test "does not eat cookies when origin=null (non-ajax or local file)" do
      {:ok, token, _} = DiscoveryApi.Auth.Guardian.encode_and_sign("username", %{}, token_type: "refresh")

      %{status_code: status_code} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(
          Cookie: "something=true,#{Helper.default_guardian_token_key()}=#{token},somethingelse=false",
          Origin: "null"
        )

      assert status_code == 200
    end

    test "does not eat cookies when from the appropriate sub origin (ajax)" do
      {:ok, token, _} = DiscoveryApi.Auth.Guardian.encode_and_sign("username", %{}, token_type: "refresh")

      %{status_code: status_code} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(
          Cookie: "something=true,#{Helper.default_guardian_token_key()}=#{token},somethingelse=false",
          Origin: "discovery.integrationtests.example.com"
        )

      assert status_code == 200
    end

    test "does not eat cookies when from the appropriate origin (ajax)" do
      {:ok, token, _} = DiscoveryApi.Auth.Guardian.encode_and_sign("username", %{}, token_type: "refresh")

      %{status_code: status_code} =
        "http://localhost:4000/api/v1/dataset/search/"
        |> HTTPoison.get!(
          Cookie: "something=true,#{Helper.default_guardian_token_key()}=#{token},somethingelse=false",
          Origin: "integrationtests.example.com"
        )

      assert status_code == 200
    end
  end

  defp add_ldap_user_to_organization(uid, cn) do
    dn = [cn: cn, ou: "Group"]

    group = [
      objectClass: ["top", "groupofnames"],
      cn: cn,
      member: ["uid=#{uid},ou=People"]
    ]

    Paddle.add(dn, group)
  end

  def make_ldap_user(name) do
    dn = [uid: name, ou: "People"]

    user = [
      objectClass: ["account", "posixAccount"],
      cn: name,
      uid: name,
      loginShell: "/bin/bash",
      homeDirectory: "/home/user",
      uidNumber: 501,
      gidNumber: 100,
      userPassword: "{SSHA}/02KaNTR+p0r0KSDfDZfFQiYgyekBsdH"
    ]

    :ok = Paddle.add(dn, user)
    {:ok, [user | _]} = Paddle.get(base: "uid=#{name},ou=People")
    user
  end
end
